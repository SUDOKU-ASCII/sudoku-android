name: Android CI

permissions:
  contents: write

on:
  push:
    tags:
      - "*"
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0

      - name: Init nested submodules
        run: git submodule update --init --recursive

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.24"

      - name: Install gomobile
        run: |
          go install golang.org/x/mobile/cmd/gomobile@latest
          gomobile init

      - name: Install Android SDK / NDK
        uses: android-actions/setup-android@v3
        with:
          packages: |
            ndk;26.1.10909125

      - name: Ensure hev-socks5-tunnel present
        run: |
          set -e
          mkdir -p third_party
          if [ ! -d third_party/hev-socks5-tunnel ]; then
            git clone --recursive https://github.com/heiher/hev-socks5-tunnel third_party/hev-socks5-tunnel
          fi
          cd third_party/hev-socks5-tunnel
          git checkout 47b6cb90f4641ed9b00911ef2c521a9836b60c5b
          git submodule update --init --recursive || true


      - name: Build hev-socks5-tunnel JNI libs
        working-directory: ${{ github.workspace }}/app/src/main/jni
        env:
          ANDROID_NDK_ROOT: ${{ env.ANDROID_SDK_ROOT }}/ndk/26.1.10909125
        run: |
          set -e
          echo "=== app/src/main/jni/Android.mk ==="
          cat Android.mk
          echo "=== app/src/main/jni/hev-socks5-tunnel/Android.mk ==="
          cat hev-socks5-tunnel/Android.mk
          echo "=== third_party/hev-socks5-tunnel/Android.mk ==="
          cat ../../../../third_party/hev-socks5-tunnel/Android.mk || echo "no third_party Android.mk"

          "$ANDROID_NDK_ROOT/ndk-build" NDK_PROJECT_PATH=. APP_BUILD_SCRIPT=Android.mk
          ls -R libs || true
          mkdir -p ../jniLibs/armeabi-v7a ../jniLibs/arm64-v8a
          cp libs/armeabi-v7a/libhev-socks5-tunnel*.so ../jniLibs/armeabi-v7a/ || true
          cp libs/arm64-v8a/libhev-socks5-tunnel*.so ../jniLibs/arm64-v8a/ || true
          ls -R ../jniLibs


      - name: Build gomobile AAR (Sudoku core)
        working-directory: ${{ github.workspace }}
        env:
          ANDROID_NDK_HOME: ${{ env.ANDROID_SDK_ROOT }}/ndk/26.1.10909125
        run: |
          bash scripts/build_sudoku_aar.sh

      - name: Cache Gradle
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Prepare signing keystore
        env:
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
        run: |
          set -e
          if [ -n "$ANDROID_KEYSTORE_BASE64" ]; then
            echo "$ANDROID_KEYSTORE_BASE64" | base64 -d > github.keystore
            echo "Using persistent keystore from ANDROID_KEYSTORE_BASE64 secret."
          else
            echo "WARNING: ANDROID_KEYSTORE_BASE64 not set; generating ephemeral keystore (signatures will differ between runs)." >&2
            keytool -genkeypair -v \
              -keystore github.keystore \
              -storepass github \
              -keypass github \
              -alias github \
              -keyalg RSA \
              -keysize 2048 \
              -validity 10000 \
              -dname "CN=GitHub CI, OU=CI, O=GitHub, L=Internet, S=Internet, C=US"
          fi

      - name: Build APK
        env:
          ANDROID_NDK_ROOT: ${{ env.ANDROID_SDK_ROOT }}/ndk/26.1.10909125
        run: ./gradlew :app:assembleRelease

      - name: Collect APKs
        run: |
          set -euo pipefail
          ref="${GITHUB_REF_NAME:-dev}"
          safe_ref="${ref//\//_}"
          apk_dir="app/build/outputs/apk/release"
          meta="$apk_dir/output-metadata.json"
          outdir="dist"
          mkdir -p "$outdir"

          echo "APK directory:"
          ls -la "$apk_dir" || true
          echo "APK files:"
          ls -la "$apk_dir"/*.apk || true
          echo "Output metadata:"
          if [ -f "$meta" ]; then
            cat "$meta"
          else
            echo "WARNING: $meta not found" >&2
          fi

          python3 - <<'PY'
          from __future__ import annotations

          import json
          import os
          import shutil
          import sys
          import zipfile
          from pathlib import Path

          apk_dir = Path("app/build/outputs/apk/release")
          outdir = Path("dist")
          outdir.mkdir(parents=True, exist_ok=True)

          safe_ref = (os.environ.get("GITHUB_REF_NAME") or "dev").replace("/", "_")

          meta = apk_dir / "output-metadata.json"
          apks = sorted(apk_dir.glob("*.apk"))
          if not apks:
              sys.exit(f"No APKs found under {apk_dir}")

          def pick_from_metadata() -> dict[str, Path] | None:
              if not meta.exists():
                  return None
              try:
                  data = json.loads(meta.read_text(encoding="utf-8"))
              except Exception as e:
                  print(f"WARNING: failed to parse {meta}: {e}", file=sys.stderr)
                  return None
              elements = data.get("elements") or []
              if not isinstance(elements, list):
                  return None

              def find_by_abi(value: str) -> Path | None:
                  for el in elements:
                      filters = el.get("filters") or []
                      for f in filters:
                          if f.get("filterType") == "ABI" and f.get("value") == value:
                              out = el.get("outputFile")
                              if out:
                                  p = apk_dir / out
                                  if p.exists():
                                      return p
                  return None

              arm64 = find_by_abi("arm64-v8a")
              armv7 = find_by_abi("armeabi-v7a")
              universal = find_by_abi("universal")
              if universal is None:
                  # Some AGP versions represent universal as "no filters".
                  for el in elements:
                      filters = el.get("filters") or []
                      out = el.get("outputFile")
                      if out and not filters:
                          p = apk_dir / out
                          if p.exists():
                              universal = p
                              break

              if arm64 and armv7 and universal:
                  return {"arm64-v8a": arm64, "armeabi-v7a": armv7, "universal": universal}
              return None

          def abis_in_apk(apk: Path) -> set[str]:
              abis: set[str] = set()
              with zipfile.ZipFile(apk) as z:
                  for name in z.namelist():
                      if not name.startswith("lib/") or not name.endswith(".so"):
                          continue
                      parts = name.split("/", 2)
                      if len(parts) >= 3:
                          abis.add(parts[1])
              return abis

          picked = pick_from_metadata()
          if picked is None:
              print("Metadata did not yield all outputs; falling back to inspecting APK contents.", file=sys.stderr)
              candidates: dict[str, list[Path]] = {"arm64-v8a": [], "armeabi-v7a": [], "universal": []}
              for apk in apks:
                  abis = abis_in_apk(apk)
                  if {"arm64-v8a", "armeabi-v7a"}.issubset(abis):
                      candidates["universal"].append(apk)
                  elif "arm64-v8a" in abis:
                      candidates["arm64-v8a"].append(apk)
                  elif "armeabi-v7a" in abis:
                      candidates["armeabi-v7a"].append(apk)

              def choose(xs: list[Path]) -> Path | None:
                  if not xs:
                      return None
                  xs_sorted = sorted(xs, key=lambda p: (("universal" not in p.name), -p.stat().st_size, p.name))
                  return xs_sorted[0]

              picked = {
                  "arm64-v8a": choose(candidates["arm64-v8a"]),
                  "armeabi-v7a": choose(candidates["armeabi-v7a"]),
                  "universal": choose(candidates["universal"]),
              }

          missing = [k for k, v in picked.items() if not v]
          if missing:
              print("ERROR: missing expected APK(s): " + ", ".join(missing), file=sys.stderr)
              print("Detected APKs:", file=sys.stderr)
              for apk in apks:
                  print(f"  - {apk.name} (abis={sorted(abis_in_apk(apk))})", file=sys.stderr)
              sys.exit(1)

          out_map = {
              "universal": outdir / f"sudodroid-{safe_ref}-universal.apk",
              "arm64-v8a": outdir / f"sudodroid-{safe_ref}-arm64-v8a.apk",
              "armeabi-v7a": outdir / f"sudodroid-{safe_ref}-armeabi-v7a.apk",
          }
          for k, src in picked.items():
              dst = out_map[k]
              assert src is not None
              shutil.copy2(src, dst)
              print(f"Collected {k}: {src} -> {dst}")
          PY

          echo "Collected:"
          ls -la "$outdir"

      - name: Upload universal APK
        uses: actions/upload-artifact@v4
        with:
          name: sudodroid-universal
          path: dist/*-universal.apk

      - name: Upload arm64-v8a APK
        uses: actions/upload-artifact@v4
        with:
          name: sudodroid-arm64-v8a
          path: dist/*-arm64-v8a.apk

      - name: Upload armeabi-v7a APK
        uses: actions/upload-artifact@v4
        with:
          name: sudodroid-armeabi-v7a
          path: dist/*-armeabi-v7a.apk

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        if: startsWith(github.ref, 'refs/tags/')
        with:
          name: Sudodroid ${{ github.ref_name }}
          files: dist/*.apk
          body: |
            Automated release for ${{ github.ref_name }} including universal, armeabi-v7a, and arm64-v8a APKs.
